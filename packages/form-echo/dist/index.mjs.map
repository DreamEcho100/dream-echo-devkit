{"version":3,"sources":["../src/utils/zod.ts","../src/utils/inputDateHelpers.ts","../src/utils/zustand.ts","../src/utils/index.ts"],"sourcesContent":["import { type ZodError, type ZodSchema } from 'zod';\r\n\r\nexport function isZodValidator(validator: unknown): validator is ZodSchema {\r\n\treturn !!(\r\n\t\tvalidator instanceof Object &&\r\n\t\t'parseAsync' in validator &&\r\n\t\ttypeof validator.parseAsync === 'function'\r\n\t);\r\n}\r\n\r\nexport function isZodError(error: unknown): error is ZodError {\r\n\treturn error instanceof Object && 'errors' in error;\r\n}\r\n\r\n// export const generateUUIDV4 = () =>\r\n// \t'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n// \t\tconst r = (Math.random() * 16) | 0;\r\n// \t\tconst v = c === 'x' ? r : (r & 0x3) | 0x8;\r\n// \t\treturn v.toString(16);\r\n// \t});\r\n\r\nexport function errorFormatter(error: unknown) {\r\n\tif (isZodError(error)) return error.format()._errors.join(', ');\r\n\r\n\tif (error instanceof Error) return error.message;\r\n\r\n\treturn 'Something went wrong!';\r\n}\r\n","import type { InputDateTypes } from '../types';\r\n\r\n/**\r\n * Formats a date object to the desired string format based on the type.\r\n * @param {Date} date - The Date object to be formatted.\r\n * @param {string} type - The format type ('date', 'time', 'datetime-local', 'week', or 'month').\r\n * @returns {string} A formatted string based on the specified format.\r\n */\r\nexport function formatDate(date: Date, type: InputDateTypes): string {\r\n\t// Initialize an empty string to hold the formatted date\r\n\tlet formattedDate = '';\r\n\r\n\t// Use a switch statement to determine the appropriate formatting based on the `type` argument\r\n\tswitch (type) {\r\n\t\tcase 'date':\r\n\t\t\t// For the 'date' type, format the date as yyyy-mm-dd using toISOString and slice\r\n\t\t\tformattedDate = date.toISOString().slice(0, 10);\r\n\t\t\tbreak;\r\n\t\tcase 'time':\r\n\t\t\t// For the 'time' type, format the time as hh:mm:ss using toTimeString and slice\r\n\t\t\tformattedDate = date.toTimeString().slice(0, 8);\r\n\t\t\tbreak;\r\n\t\tcase 'datetime-local':\r\n\t\t\t// For the 'datetime-local' type, format the date and time as yyyy-mm-ddThh:mm:ss using toISOString, slice, and replace\r\n\t\t\t// formattedDate = date.toISOString().slice(0, 16);\r\n\t\t\t// formattedDate = formattedDate.replace('T', ' ');\r\n\t\t\tformattedDate = `${date.getFullYear()}-${`${\r\n\t\t\t\tdate.getMonth() + 1\r\n\t\t\t}`.padStart(2, '0')}-${`${date.getDate()}`.padStart(\r\n\t\t\t\t2,\r\n\t\t\t\t'0',\r\n\t\t\t)}T${`${date.getHours()}`.padStart(\r\n\t\t\t\t2,\r\n\t\t\t\t'0',\r\n\t\t\t)}:${`${date.getMinutes()}`.padStart(2, '0')}`;\r\n\t\t\tbreak;\r\n\t\tcase 'week':\r\n\t\t\t// For the 'week' type, format the week as yyyy-Www using getWeekNumber and padStart\r\n\t\t\tconst year = date.getFullYear();\r\n\t\t\tconst weekNumber = getWeekNumber(date);\r\n\t\t\tformattedDate = `${year}-W${\r\n\t\t\t\tweekNumber.toString().length < 2\r\n\t\t\t\t\t? '0' + weekNumber.toString()\r\n\t\t\t\t\t: weekNumber.toString()\r\n\t\t\t}`;\r\n\t\t\t// weekNumber.toString().padStart(2, '0')\r\n\t\t\tbreak;\r\n\t\tcase 'month':\r\n\t\t\t// For the 'month' type, format the month as yyyy-mm using toISOString and slice\r\n\t\t\tformattedDate = date.toISOString().slice(0, 7);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// If the type is not recognized, return an empty string\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t// Return the formatted date\r\n\treturn formattedDate;\r\n}\r\n\r\n/**\r\n * Parses a string in the specified format and returns a Date object.\r\n * @param {string} dateString - The string to be parsed.\r\n * @param {string} type - The format type ('date', 'time', 'datetime-local', 'week', or 'month').\r\n * @returns {Date} - The parsed Date object.\r\n */\r\nexport function parseDate(\r\n\tdateString: string | number,\r\n\ttype: InputDateTypes,\r\n): Date {\r\n\t// Declare a variable to hold the parsed date\r\n\tlet parsedDate: Date;\r\n\r\n\t// Use a switch statement to handle the various date/time formats\r\n\tswitch (type) {\r\n\t\tcase 'date':\r\n\t\t\t// For the 'date' type, parse the string as a date in ISO format (yyyy-mm-dd)\r\n\t\t\tparsedDate = new Date(dateString);\r\n\t\t\tbreak;\r\n\t\tcase 'time':\r\n\t\t\t// For the 'time' type, split the string into hours, minutes, and seconds components\r\n\t\t\tconst [hours, minutes, seconds] = dateString.toString().split(':');\r\n\t\t\t// Create a new Date object and set the hours, minutes, and seconds based on the input string\r\n\t\t\tparsedDate = new Date();\r\n\t\t\tparsedDate.setHours(Number(hours || 0));\r\n\t\t\tparsedDate.setMinutes(Number(minutes || 0));\r\n\t\t\tparsedDate.setSeconds(Number(seconds || 0));\r\n\t\t\tbreak;\r\n\t\tcase 'datetime-local':\r\n\t\t\t// For the 'datetime-local' type, replace the space character with 'T' and parse the resulting string as a date in ISO format\r\n\t\t\tparsedDate = new Date(dateString.toString().replace(' ', 'T'));\r\n\t\t\tbreak;\r\n\t\tcase 'week':\r\n\t\t\t// For the 'week' type, split the string into year and week number components\r\n\t\t\tconst [yearString, weekString] = dateString.toString().split('-W');\r\n\t\t\tconst year = Number(yearString);\r\n\t\t\tconst week = Number(weekString);\r\n\t\t\t// Use the getFirstDateOfWeek helper function to calculate the first date of the specified week in the specified year\r\n\t\t\tparsedDate = getFirstDateOfWeek(year, week);\r\n\t\t\tbreak;\r\n\t\tcase 'month':\r\n\t\t\t// For the 'month' type, append '-01' to the input string to represent the first day of the month and parse as a date in ISO format\r\n\t\t\tparsedDate = new Date(`${dateString}-01`);\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// For an unrecognized format, return the current date/time\r\n\t\t\tparsedDate = new Date();\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t// Return the parsed Date object\r\n\treturn parsedDate;\r\n}\r\n\r\n/**\r\n * Returns the week number of the year for a given date.\r\n * @param {Date} date - The date object for which to calculate the week number.\r\n * @returns {number} - The week number.\r\n */\r\nexport function getWeekNumber(date: Date): number {\r\n\t// Get the date for the first day of the year\r\n\tconst yearStart = new Date(date.getFullYear(), 0, 1);\r\n\r\n\t// Calculate the number of days since the start of the year until the given date\r\n\tconst daysSinceYearStart =\r\n\t\t(date.valueOf() - yearStart.valueOf()) / (1000 * 60 * 60 * 24);\r\n\r\n\t// Calculate the week number by dividing the number of days by 7 and rounding down\r\n\tconst weekNumber = Math.floor(daysSinceYearStart / 7) + 1;\r\n\r\n\treturn weekNumber;\r\n}\r\n\r\n/**\r\n * Returns the first date (Monday) of a given week in a year.\r\n * @param {number} year - The year of the target week.\r\n * @param {number} week - The week number (1-53) of the desired week.\r\n * @returns {Date} - The first date (Monday) of the specified week.\r\n */\r\nexport function getFirstDateOfWeek(year: number, week: number): Date {\r\n\t// Find the date of January 1st for the given year\r\n\tconst januaryFirst = new Date(year, 0, 1);\r\n\r\n\t// Calculate the number of days until the first Monday of the year\r\n\t// 0 represents Sunday, 1 represents Monday, and so on\r\n\tconst daysToFirstMonday = (8 - januaryFirst.getDay()) % 7;\r\n\r\n\t// Set the date object to the first Monday of the year\r\n\tconst firstMonday = new Date(januaryFirst);\r\n\tfirstMonday.setDate(januaryFirst.getDate() + daysToFirstMonday);\r\n\r\n\t// Calculate the number of days until the target Monday of the week\r\n\tconst daysToTargetMonday = (week - 1) * 7;\r\n\r\n\t// Set the date object to the target Monday of the week\r\n\tconst targetMonday = new Date(firstMonday);\r\n\ttargetMonday.setDate(firstMonday.getDate() + daysToTargetMonday);\r\n\r\n\treturn targetMonday;\r\n}\r\n\r\n/**\r\n * A collection of helper functions for working with input date values.\r\n * @namespace\r\n */\r\nexport const inputDateHelpers = {\r\n\t/**\r\n\t * Formats a date object to the desired string format based on the type.\r\n\t * @param {Date} date - The Date object to be formatted.\r\n\t * @param {string} type - The format type ('date', 'time', 'datetime-local', 'week', or 'month').\r\n\t * @returns {string} A formatted string based on the specified format.\r\n\t */\r\n\tformatDate,\r\n\r\n\t/**\r\n\t * Parses a string in the specified format and returns a Date object.\r\n\t * @param {string} dateString - The string to be parsed.\r\n\t * @param {string} type - The format type ('date', 'time', 'datetime-local', 'week', or 'month').\r\n\t * @returns {Date} - The parsed Date object.\r\n\t */\r\n\tparseDate,\r\n\r\n\t/**\r\n\t * Returns the week number of the year for a given date.\r\n\t * @param {Date} date - The date object for which to calculate the week number.\r\n\t * @returns {number} - The week number.\r\n\t */\r\n\tgetWeekNumber,\r\n\r\n\t/**\r\n\t * Returns the first date (Monday) of a given week in a year.\r\n\t * @param {number} year - The year of the target week.\r\n\t * @param {number} week - The week number (1-53) of the desired week.\r\n\t * @returns {Date} - The first date (Monday) of the specified week.\r\n\t */\r\n\tgetFirstDateOfWeek,\r\n};\r\n\r\nexport default inputDateHelpers;\r\n","import { createStore } from 'zustand';\r\nimport { type CreateFormStoreProps } from '../types';\r\nimport { createFormStoreBuilder } from '.';\r\nimport { useId, useState } from 'react';\r\n\r\nexport const handleCreateFormStore = <FieldsValues, ValidationsHandlers>(\r\n\tparams: CreateFormStoreProps<FieldsValues, ValidationsHandlers>,\r\n) => createStore(createFormStoreBuilder(params));\r\n\r\nexport const useCreateFormStore = <FieldsValues, ValidationsHandlers>(\r\n\tprops: Omit<\r\n\t\tCreateFormStoreProps<FieldsValues, ValidationsHandlers>,\r\n\t\t'baseId'\r\n\t> & {\r\n\t\tbaseId?: CreateFormStoreProps<FieldsValues, ValidationsHandlers>['baseId'];\r\n\t},\r\n) => {\r\n\tconst baseId = useId();\r\n\tconst formStore = useState(\r\n\t\thandleCreateFormStore({ ...props, baseId: props.baseId || baseId }),\r\n\t);\r\n\r\n\treturn formStore[0];\r\n};\r\n","import { type FormEvent } from 'react';\r\nimport {\r\n\ttype ValidationEvents,\r\n\ttype CreateFormStoreProps,\r\n\ttype FormStoreShape,\r\n\ttype GetFromFormStoreShape,\r\n\t// type HandlePreSubmit,\r\n\ttype HandleSubmitCB,\r\n\ttype GetValidationValuesFromSchema,\r\n} from '../types';\r\nimport { errorFormatter, isZodValidator } from './zod';\r\n\r\nexport * from './inputDateHelpers';\r\nexport * from './zod';\r\nexport * from './zustand';\r\n\r\ntype SetStateInternal<T> = (\r\n\tpartial: T | Partial<T> | ((state: T) => T | Partial<T>),\r\n\t// replace?: boolean | undefined,\r\n) => void;\r\n\r\nfunction createFormStoreMetadata<FieldsValues, ValidationsHandlers>(\r\n\tparams: CreateFormStoreProps<FieldsValues, ValidationsHandlers>,\r\n\tbaseId: string,\r\n) {\r\n\ttype FormStore = FormStoreShape<FieldsValues, ValidationsHandlers>;\r\n\tif (!params.initValues || typeof params.initValues !== 'object')\r\n\t\tthrow new Error('');\r\n\r\n\tconst metadata = {\r\n\t\tbaseId,\r\n\t\tformId: `${baseId}_form`,\r\n\t\tfieldsNames: {},\r\n\t\tfieldsNamesMap: {},\r\n\t\t//\r\n\t\tvalidatedFieldsNames: [],\r\n\t\tvalidatedFieldsNamesMap: {},\r\n\t\t// //\r\n\t\tmanualValidatedFields: [],\r\n\t\tmanualValidatedFieldsMap: [],\r\n\t\t// //\r\n\t\treferencedValidatedFields: [],\r\n\t\treferencedValidatedFieldsMap: [],\r\n\t} as unknown as FormStore['metadata'];\r\n\r\n\tmetadata.fieldsNames = Object.keys(\r\n\t\tparams.initValues,\r\n\t) as typeof metadata.fieldsNames;\r\n\tfor (const fieldName of metadata.fieldsNames) {\r\n\t\tmetadata.fieldsNamesMap[fieldName] = true;\r\n\t}\r\n\tfor (const key in params.validationsSchema) {\r\n\t\tmetadata.validatedFieldsNames.push(key);\r\n\t\tmetadata.validatedFieldsNamesMap[key] = true;\r\n\r\n\t\tif (key in metadata.fieldsNamesMap) {\r\n\t\t\tmetadata.referencedValidatedFields.push(\r\n\t\t\t\tkey as unknown as (typeof metadata)['referencedValidatedFields'][number],\r\n\t\t\t);\r\n\t\t\tmetadata.referencedValidatedFieldsMap[\r\n\t\t\t\tkey as unknown as (typeof metadata)['referencedValidatedFields'][number]\r\n\t\t\t] = true;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tmetadata.manualValidatedFields.push(\r\n\t\t\tkey as unknown as (typeof metadata)['manualValidatedFields'][number],\r\n\t\t);\r\n\t\t(metadata.manualValidatedFieldsMap as Record<string, true>)[\r\n\t\t\tkey // as unknown as (typeof metadata)['manualValidatedFieldsMap'][number]\r\n\t\t] = true;\r\n\t}\r\n\r\n\treturn metadata;\r\n}\r\n\r\nfunction createFormStoreValidations<FieldsValues, ValidationsHandlers>(\r\n\tparams: CreateFormStoreProps<FieldsValues, ValidationsHandlers>,\r\n\tmetadata: FormStoreShape<FieldsValues, ValidationsHandlers>['metadata'],\r\n) {\r\n\ttype FormStore = FormStoreShape<FieldsValues, ValidationsHandlers>;\r\n\r\n\tlet fieldValidationEvents: NonNullable<typeof params.validationEvents> = {\r\n\t\tsubmit: true,\r\n\t};\r\n\tlet isFieldHavingPassedValidations = false;\r\n\tlet fieldValidationEventKey: ValidationEvents;\r\n\r\n\tconst validations: FormStore['validations'] = {} as FormStore['validations'];\r\n\tfor (const fieldName of metadata.validatedFieldsNames) {\r\n\t\tconst fieldValidationsHandler =\r\n\t\t\tparams.validationsSchema?.[\r\n\t\t\t\tfieldName as keyof GetFromFormStoreShape<FormStore> &\r\n\t\t\t\t\tkeyof GetFromFormStoreShape<FormStore, 'validationHandlers'>\r\n\t\t\t];\r\n\r\n\t\tvalidations[fieldName] = {\r\n\t\t\thandler: !fieldValidationsHandler\r\n\t\t\t\t? undefined\r\n\t\t\t\t: isZodValidator(fieldValidationsHandler)\r\n\t\t\t\t? (value: unknown) => fieldValidationsHandler.parse(value)\r\n\t\t\t\t: fieldValidationsHandler,\r\n\t\t\tcurrentDirtyEventsCounter: 0,\r\n\t\t\tfailedAttempts: 0,\r\n\t\t\tpassedAttempts: 0,\r\n\t\t\tevents: {\r\n\t\t\t\t// blur: { failedAttempts: 0, passedAttempts: 0, isActive: false },\r\n\t\t\t\t// mount: { failedAttempts: 0, passedAttempts: 0, isActive: false },\r\n\t\t\t\tchange: {\r\n\t\t\t\t\tfailedAttempts: 0,\r\n\t\t\t\t\tpassedAttempts: 0,\r\n\t\t\t\t\tisActive: false,\r\n\t\t\t\t\tisDirty: false,\r\n\t\t\t\t\terror: null,\r\n\t\t\t\t},\r\n\t\t\t\tsubmit: {\r\n\t\t\t\t\tfailedAttempts: 0,\r\n\t\t\t\t\tpassedAttempts: 0,\r\n\t\t\t\t\tisActive: false,\r\n\t\t\t\t\tisDirty: false,\r\n\t\t\t\t\terror: null,\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t\tisDirty: false,\r\n\t\t\tmetadata: { name: fieldName },\r\n\t\t} as NonNullable<FormStore['validations'][keyof FormStore['validations']]>;\r\n\r\n\t\tif (params.validationEvents) {\r\n\t\t\tisFieldHavingPassedValidations = true;\r\n\t\t\tfieldValidationEvents = {\r\n\t\t\t\t...fieldValidationEvents,\r\n\t\t\t\t...params.validationEvents,\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (isFieldHavingPassedValidations) {\r\n\t\t\tfor (fieldValidationEventKey in fieldValidationEvents) {\r\n\t\t\t\tvalidations[fieldName].events[fieldValidationEventKey].isActive =\r\n\t\t\t\t\t!!typeof fieldValidationEvents[fieldValidationEventKey];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn validations;\r\n}\r\n\r\nfunction createFormStoreFields<FieldsValues, ValidationsHandlers>(\r\n\tparams: CreateFormStoreProps<FieldsValues, ValidationsHandlers>,\r\n\tbaseId: string,\r\n\tmetadata: FormStoreShape<FieldsValues, ValidationsHandlers>['metadata'],\r\n) {\r\n\ttype FormStore = FormStoreShape<FieldsValues, ValidationsHandlers>;\r\n\r\n\tconst isUpdatingValueOnError = params.isUpdatingFieldsValueOnError ?? true;\r\n\r\n\tconst fields = {} as FormStore['fields'];\r\n\tfor (const fieldName of metadata.fieldsNames) {\r\n\t\tfields[fieldName] = {\r\n\t\t\tvalue: params.initValues[fieldName],\r\n\t\t\tisUpdatingValueOnError,\r\n\t\t\tvalueFromFieldToStore: params.valuesFromFieldsToStore?.[fieldName]\r\n\t\t\t\t? params.valuesFromFieldsToStore[fieldName]\r\n\t\t\t\t: undefined,\r\n\t\t\tvalueFromStoreToField: params.valuesFromStoreToFields?.[fieldName]\r\n\t\t\t\t? params.valuesFromStoreToFields[fieldName]\r\n\t\t\t\t: undefined,\r\n\t\t\terrors: null,\r\n\t\t\tisDirty: false,\r\n\t\t\tid: `${baseId}field-${String(fieldName)}`,\r\n\t\t\tmetadata: {\r\n\t\t\t\tname: fieldName,\r\n\t\t\t\tinitialValue: params.initValues[fieldName],\r\n\t\t\t},\r\n\t\t} as (typeof fields)[typeof fieldName];\r\n\t}\r\n\r\n\treturn fields;\r\n}\r\n\r\nconst itemsToResetDefaults = {\r\n\tfields: true,\r\n\tvalidations: true,\r\n\tsubmitCounter: false,\r\n};\r\n\r\n// \t{\r\n// isUpdatingFieldsValueOnError = true,\r\n// trackValidationHistory = false,\r\n// valuesFromFieldsToStore,\r\n// valuesFromStoreToFields,\r\n// validationSchema: passedValidationSchema,\r\n// ...params\r\n// \t}\r\nexport function createFormStoreBuilder<FieldsValues, ValidationsHandlers>(\r\n\tparams: CreateFormStoreProps<FieldsValues, ValidationsHandlers>,\r\n) {\r\n\t// type FormStore = FormStoreShape<FieldsValues, ValidationsHandlers>;\r\n\r\n\tconst baseId = params.baseId ? `${params.baseId}-` : '';\r\n\tconst metadata = createFormStoreMetadata(params, baseId);\r\n\tconst fields = createFormStoreFields(params, baseId, metadata);\r\n\tconst validations = createFormStoreValidations(params, metadata);\r\n\r\n\treturn (\r\n\t\tset: SetStateInternal<FormStoreShape<FieldsValues, ValidationsHandlers>>,\r\n\t\tget: () => FormStoreShape<FieldsValues, ValidationsHandlers>,\r\n\t): FormStoreShape<FieldsValues, ValidationsHandlers> => {\r\n\t\treturn {\r\n\t\t\tbaseId,\r\n\t\t\tmetadata,\r\n\t\t\tvalidations,\r\n\t\t\tfields,\r\n\t\t\tid: `${baseId}-form`,\r\n\t\t\tisDirty: false,\r\n\t\t\tisSubmitting: false,\r\n\t\t\tsubmitCounter: 0,\r\n\t\t\tcurrentDirtyFieldsCounter: 0,\r\n\t\t\tutils: {\r\n\t\t\t\tsetIsSubmitting(valueOrUpdater) {\r\n\t\t\t\t\tset(function (currentStore) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t...currentStore,\r\n\t\t\t\t\t\t\tisSubmitting:\r\n\t\t\t\t\t\t\t\ttypeof valueOrUpdater === 'function'\r\n\t\t\t\t\t\t\t\t\t? valueOrUpdater(currentStore.isSubmitting)\r\n\t\t\t\t\t\t\t\t\t: valueOrUpdater,\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\tresetFormStore: function (itemsToReset = itemsToResetDefaults) {\r\n\t\t\t\t\treturn set(function (currentState) {\r\n\t\t\t\t\t\tconst fields = currentState.fields;\r\n\t\t\t\t\t\tconst validations = currentState.validations;\r\n\t\t\t\t\t\tlet isDirty = currentState.isDirty;\r\n\t\t\t\t\t\tlet submitCounter = currentState.submitCounter;\r\n\r\n\t\t\t\t\t\tif (itemsToReset.fields) {\r\n\t\t\t\t\t\t\tfor (const key in fields) {\r\n\t\t\t\t\t\t\t\tfields[key].value = fields[key].metadata.initialValue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (itemsToReset.validations) {\r\n\t\t\t\t\t\t\tfor (const key in validations) {\r\n\t\t\t\t\t\t\t\tvalidations[key].failedAttempts = 0;\r\n\t\t\t\t\t\t\t\tvalidations[key].passedAttempts = 0;\r\n\t\t\t\t\t\t\t\tvalidations[key].isDirty = false;\r\n\t\t\t\t\t\t\t\tvalidations[key].error = null;\r\n\r\n\t\t\t\t\t\t\t\tlet eventKey: keyof (typeof validations)[typeof key]['events'];\r\n\t\t\t\t\t\t\t\tfor (eventKey in validations[key].events) {\r\n\t\t\t\t\t\t\t\t\t// validations[key].events[eventKey].\r\n\t\t\t\t\t\t\t\t\tvalidations[key].events[eventKey].failedAttempts = 0;\r\n\t\t\t\t\t\t\t\t\tvalidations[key].events[eventKey].passedAttempts = 0;\r\n\t\t\t\t\t\t\t\t\tvalidations[key].events[eventKey].isDirty = false;\r\n\t\t\t\t\t\t\t\t\tvalidations[key].events[eventKey].error = null;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tisDirty = false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (itemsToReset.submitCounter) {\r\n\t\t\t\t\t\t\tsubmitCounter = 0;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t...currentState,\r\n\t\t\t\t\t\t\tfields,\r\n\t\t\t\t\t\t\tvalidations,\r\n\t\t\t\t\t\t\tisDirty,\r\n\t\t\t\t\t\t\tsubmitCounter,\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\t// errorFormatter: (error) => {\r\n\t\t\t\t// \tif (isZodError(error)) return error.format()._errors;\r\n\r\n\t\t\t\t// \tif (error instanceof Error) return [error.message];\r\n\t\t\t\t// \treturn ['Something went wrong!'];\r\n\t\t\t\t// },\r\n\t\t\t\tsetFieldValue(name, value) {\r\n\t\t\t\t\treturn set(function (currentState) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tfields: {\r\n\t\t\t\t\t\t\t\t...currentState.fields,\r\n\t\t\t\t\t\t\t\t[name]: {\r\n\t\t\t\t\t\t\t\t\t...currentState.fields[name],\r\n\t\t\t\t\t\t\t\t\tvalue:\r\n\t\t\t\t\t\t\t\t\t\ttypeof value === 'function'\r\n\t\t\t\t\t\t\t\t\t\t\t? (value(\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentState.fields[name].value,\r\n\t\t\t\t\t\t\t\t\t\t\t  ) as FieldsValues[typeof name])\r\n\t\t\t\t\t\t\t\t\t\t\t: value,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\tsetFieldErrors(params) {\r\n\t\t\t\t\tset(function (currentState) {\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t!currentState.validations[params.name].events[\r\n\t\t\t\t\t\t\t\tparams.validationEvent\r\n\t\t\t\t\t\t\t].isActive\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\treturn currentState;\r\n\r\n\t\t\t\t\t\tlet currentDirtyFieldsCounter =\r\n\t\t\t\t\t\t\tcurrentState.currentDirtyFieldsCounter;\r\n\t\t\t\t\t\tconst validation = currentState.validations[params.name];\r\n\r\n\t\t\t\t\t\tif (params.message) {\r\n\t\t\t\t\t\t\tvalidation.failedAttempts++;\r\n\t\t\t\t\t\t\tvalidation.events[params.validationEvent].failedAttempts++;\r\n\r\n\t\t\t\t\t\t\tif (!validation.events[params.validationEvent].isDirty) {\r\n\t\t\t\t\t\t\t\tvalidation.currentDirtyEventsCounter++;\r\n\t\t\t\t\t\t\t\tif (validation.currentDirtyEventsCounter > 0) {\r\n\t\t\t\t\t\t\t\t\tcurrentDirtyFieldsCounter++;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvalidation.events[params.validationEvent].error = {\r\n\t\t\t\t\t\t\t\tmessage: params.message,\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\tvalidation.error = { message: params.message };\r\n\t\t\t\t\t\t\tvalidation.events[params.validationEvent].isDirty = true;\r\n\t\t\t\t\t\t\tvalidation.isDirty = true;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalidation.passedAttempts++;\r\n\t\t\t\t\t\t\tvalidation.events[params.validationEvent].passedAttempts++;\r\n\r\n\t\t\t\t\t\t\tif (validation.events[params.validationEvent].isDirty) {\r\n\t\t\t\t\t\t\t\tvalidation.currentDirtyEventsCounter--;\r\n\t\t\t\t\t\t\t\tif (validation.currentDirtyEventsCounter === 0) {\r\n\t\t\t\t\t\t\t\t\tcurrentDirtyFieldsCounter--;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tvalidation.events[params.validationEvent].error = null;\r\n\t\t\t\t\t\t\tvalidation.error = null;\r\n\t\t\t\t\t\t\tvalidation.events[params.validationEvent].isDirty = false;\r\n\t\t\t\t\t\t\tvalidation.isDirty = false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t...currentState,\r\n\t\t\t\t\t\t\tcurrentDirtyFieldsCounter,\r\n\t\t\t\t\t\t\tisDirty: currentDirtyFieldsCounter > 0,\r\n\t\t\t\t\t\t\tvalidations: {\r\n\t\t\t\t\t\t\t\t...currentState.validations,\r\n\t\t\t\t\t\t\t\t[params.name]: validation,\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t});\r\n\t\t\t\t},\r\n\t\t\t\terrorFormatter: params.errorFormatter ?? errorFormatter,\r\n\t\t\t\thandleOnInputChange(name, valueOrUpdater, validationName) {\r\n\t\t\t\t\tconst currentState = get();\r\n\t\t\t\t\tconst field = currentState.fields[name];\r\n\r\n\t\t\t\t\tconst value = (\r\n\t\t\t\t\t\ttypeof valueOrUpdater === 'function'\r\n\t\t\t\t\t\t\t? valueOrUpdater(field.value)\r\n\t\t\t\t\t\t\t: field.valueFromFieldToStore\r\n\t\t\t\t\t\t\t? field.valueFromFieldToStore(valueOrUpdater)\r\n\t\t\t\t\t\t\t: valueOrUpdater\r\n\t\t\t\t\t) as FieldsValues[typeof name];\r\n\r\n\t\t\t\t\tconst _validationName = (\r\n\t\t\t\t\t\tvalidationName\r\n\t\t\t\t\t\t\t? validationName\r\n\t\t\t\t\t\t\t: // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n\t\t\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\t\t\tcurrentState.metadata.referencedValidatedFieldsMap[\r\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n\t\t\t\t\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\t\t\t\t\tname as (typeof currentState)['metadata']['referencedValidatedFieldsMap']\r\n\t\t\t\t\t\t\t  ]\r\n\t\t\t\t\t\t\t? name\r\n\t\t\t\t\t\t\t: undefined\r\n\t\t\t\t\t) as typeof validationName;\r\n\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t_validationName &&\r\n\t\t\t\t\t\tcurrentState.validations[_validationName].events['change'].isActive\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tcurrentState.utils.setFieldValue(\r\n\t\t\t\t\t\t\t\tname,\r\n\t\t\t\t\t\t\t\tcurrentState.validations[_validationName].handler(\r\n\t\t\t\t\t\t\t\t\tvalue,\r\n\t\t\t\t\t\t\t\t\t'change',\r\n\t\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcurrentState.utils.setFieldErrors({\r\n\t\t\t\t\t\t\t\tname: _validationName,\r\n\t\t\t\t\t\t\t\tmessage: null,\r\n\t\t\t\t\t\t\t\tvalidationEvent: 'change',\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t\tcurrentState.utils.setFieldErrors({\r\n\t\t\t\t\t\t\t\tname: _validationName,\r\n\t\t\t\t\t\t\t\tmessage: currentState.utils.errorFormatter(error, 'change'),\r\n\t\t\t\t\t\t\t\tvalidationEvent: 'change',\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tif (field.isUpdatingValueOnError)\r\n\t\t\t\t\t\t\t\tcurrentState.utils.setFieldValue(name, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcurrentState.utils.setFieldValue(name, value);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\thandleSubmit<FieldsValues, ValidationsHandlers>(\r\n\t\t\t\t\tcb: HandleSubmitCB<FieldsValues, ValidationsHandlers>,\r\n\t\t\t\t) {\r\n\t\t\t\t\treturn async function (\r\n\t\t\t\t\t\tevent: FormEvent<HTMLFormElement>,\r\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n\t\t\t\t\t\t// @ts-ignore\r\n\t\t\t\t\t): Promise<unknown> | unknown {\r\n\t\t\t\t\t\tevent.preventDefault();\r\n\t\t\t\t\t\t// if (!cb) return;\r\n\t\t\t\t\t\tconst currentStore = get();\r\n\r\n\t\t\t\t\t\tcurrentStore.utils.setIsSubmitting(true);\r\n\r\n\t\t\t\t\t\tconst metadata = currentStore.metadata;\r\n\t\t\t\t\t\tconst fields = currentStore.fields;\r\n\t\t\t\t\t\tconst validations = currentStore.validations;\r\n\t\t\t\t\t\tconst values: Record<string, unknown> = {}; // as Fields;\r\n\t\t\t\t\t\tconst validatedValues: Record<string, unknown> = {};\r\n\r\n\t\t\t\t\t\tconst errors: Record<\r\n\t\t\t\t\t\t\tstring,\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tname: string | number | symbol;\r\n\t\t\t\t\t\t\t\terror: string | null;\r\n\t\t\t\t\t\t\t\tvalidationEvent: ValidationEvents;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t> = {};\r\n\r\n\t\t\t\t\t\tlet hasError = false;\r\n\r\n\t\t\t\t\t\t// let formFieldName: keyof typeof fields & string;\r\n\t\t\t\t\t\t// for (formFieldName in fields) {\r\n\t\t\t\t\t\t// \tvalues[formFieldName] = fields[formFieldName].value;\r\n\t\t\t\t\t\t// }\r\n\t\t\t\t\t\tlet fieldName: keyof typeof fields & string; // (typeof metadata)['referencedValidatedFieldsMap'];\r\n\t\t\t\t\t\tfor (fieldName in fields) {\r\n\t\t\t\t\t\t\tvalues[fieldName] = fields[fieldName].value;\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tconst validationSchema =\r\n\t\t\t\t\t\t\t\t\tfieldName in metadata.referencedValidatedFieldsMap &&\r\n\t\t\t\t\t\t\t\t\tvalidations[fieldName as unknown as keyof typeof validations]\r\n\t\t\t\t\t\t\t\t\t\t.handler;\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tvalidations[fieldName as unknown as keyof typeof validations]\r\n\t\t\t\t\t\t\t\t\t\t.events.submit.isActive &&\r\n\t\t\t\t\t\t\t\t\ttypeof validationSchema === 'function'\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\tvalidatedValues[fieldName] = validationSchema(\r\n\t\t\t\t\t\t\t\t\t\tfields[fieldName].value,\r\n\t\t\t\t\t\t\t\t\t\t'submit',\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\terrors[fieldName] = {\r\n\t\t\t\t\t\t\t\t\tname: fieldName,\r\n\t\t\t\t\t\t\t\t\terror: null,\r\n\t\t\t\t\t\t\t\t\tvalidationEvent: 'submit',\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t\t\terrors[fieldName] = {\r\n\t\t\t\t\t\t\t\t\tname: fieldName,\r\n\t\t\t\t\t\t\t\t\terror: currentStore.utils.errorFormatter(error, 'submit'),\r\n\t\t\t\t\t\t\t\t\tvalidationEvent: 'submit',\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t// hasError = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet manualFieldName: keyof (typeof metadata)['manualValidatedFieldsMap'];\r\n\t\t\t\t\t\tfor (manualFieldName of metadata.manualValidatedFields) {\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tconst validationSchema =\r\n\t\t\t\t\t\t\t\t\tcurrentStore.validations[manualFieldName].handler;\r\n\t\t\t\t\t\t\t\tif (typeof validationSchema === 'function') {\r\n\t\t\t\t\t\t\t\t\tvalidatedValues[manualFieldName as string] = validationSchema(\r\n\t\t\t\t\t\t\t\t\t\tvalues as FieldsValues,\r\n\t\t\t\t\t\t\t\t\t\t'submit',\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\terrors[manualFieldName as string] = {\r\n\t\t\t\t\t\t\t\t\tname: manualFieldName,\r\n\t\t\t\t\t\t\t\t\terror: null,\r\n\t\t\t\t\t\t\t\t\tvalidationEvent: 'submit',\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t} catch (error) {\r\n\t\t\t\t\t\t\t\terrors[manualFieldName as string] = {\r\n\t\t\t\t\t\t\t\t\tname: manualFieldName,\r\n\t\t\t\t\t\t\t\t\terror: currentStore.utils.errorFormatter(error, 'submit'),\r\n\t\t\t\t\t\t\t\t\tvalidationEvent: 'submit',\r\n\t\t\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\t\t\t// hasError = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttype NecessaryEvil = {\r\n\t\t\t\t\t\t\tvalues: FieldsValues;\r\n\t\t\t\t\t\t\tvalidatedValues: GetValidationValuesFromSchema<ValidationsHandlers>;\r\n\t\t\t\t\t\t\terror: Parameters<\r\n\t\t\t\t\t\t\t\t(typeof currentStore)['utils']['setFieldErrors']\r\n\t\t\t\t\t\t\t>[0];\r\n\t\t\t\t\t\t\terrors: {\r\n\t\t\t\t\t\t\t\t[Key in keyof ValidationsHandlers]: {\r\n\t\t\t\t\t\t\t\t\tname: Key;\r\n\t\t\t\t\t\t\t\t\terror: string | null;\r\n\t\t\t\t\t\t\t\t\tvalidationEvent: ValidationEvents;\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t\tlet errorKey: keyof typeof errors & string;\r\n\t\t\t\t\t\tfor (errorKey in errors) {\r\n\t\t\t\t\t\t\tconst errorObj = errors[errorKey]; // as NecessaryEvil['errors'][keyof NecessaryEvil['errors']];\r\n\r\n\t\t\t\t\t\t\tcurrentStore.utils.setFieldErrors(\r\n\t\t\t\t\t\t\t\terrors[errorKey] as unknown as NecessaryEvil['error'],\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif (typeof errorObj.error !== 'string') continue;\r\n\r\n\t\t\t\t\t\t\thasError = true;\r\n\t\t\t\t\t\t\t// currentStore.utils.setFieldErrors(\r\n\t\t\t\t\t\t\t// \terrors[errorKey], //  as NecessaryEvil['errors'][keyof NecessaryEvil['errors']],\r\n\t\t\t\t\t\t\t// );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurrentStore.utils.setIsSubmitting(false);\r\n\r\n\t\t\t\t\t\tif (hasError) return;\r\n\r\n\t\t\t\t\t\tawait cb({\r\n\t\t\t\t\t\t\tevent,\r\n\t\t\t\t\t\t\tvalues: values as NecessaryEvil['values'],\r\n\t\t\t\t\t\t\tvalidatedValues:\r\n\t\t\t\t\t\t\t\tvalidatedValues as NecessaryEvil['validatedValues'],\r\n\t\t\t\t\t\t\thasError,\r\n\t\t\t\t\t\t\terrors: errors as NecessaryEvil['errors'],\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t};\r\n\t};\r\n}\r\n\r\n// export const handleSubmit = function <FieldsValues, ValidationsHandlers>(\r\n// \tstoreGetter: () => FormStoreShape<FieldsValues, ValidationsHandlers>,\r\n// \tcb: HandleSubmitCB<FieldsValues, ValidationsHandlers>,\r\n// ) {\r\n// \treturn async function (\r\n// \t\tevent: FormEvent<HTMLFormElement>,\r\n// \t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n// \t\t// @ts-ignore\r\n// \t): Promise<unknown> | unknown {\r\n// \t\tevent.preventDefault();\r\n// \t\t// if (!cb) return;\r\n// \t\tconst currentStore = storeGetter();\r\n\r\n// \t\tcurrentStore.utils.setIsSubmitting(true);\r\n\r\n// \t\tconst metadata = currentStore.metadata;\r\n// \t\tconst fields = currentStore.fields;\r\n// \t\tconst validations = currentStore.validations;\r\n// \t\tconst values: Record<string, unknown> = {}; // as Fields;\r\n// \t\tconst validatedValues: Record<string, unknown> = {};\r\n\r\n// \t\tconst errors: Record<\r\n// \t\t\tstring,\r\n// \t\t\t{\r\n// \t\t\t\tname: string | number | symbol;\r\n// \t\t\t\terror: string | null;\r\n// \t\t\t\tvalidationEvent: ValidationEvents;\r\n// \t\t\t}\r\n// \t\t> = {};\r\n\r\n// \t\tlet hasError = false;\r\n\r\n// \t\t// let formFieldName: keyof typeof fields & string;\r\n// \t\t// for (formFieldName in fields) {\r\n// \t\t// \tvalues[formFieldName] = fields[formFieldName].value;\r\n// \t\t// }\r\n// \t\tlet fieldName: keyof typeof fields & string; // (typeof metadata)['referencedValidatedFieldsMap'];\r\n// \t\tfor (fieldName in fields) {\r\n// \t\t\tvalues[fieldName] = fields[fieldName].value;\r\n// \t\t\ttry {\r\n// \t\t\t\tconst validationSchema =\r\n// \t\t\t\t\tfieldName in metadata.referencedValidatedFieldsMap &&\r\n// \t\t\t\t\tvalidations[fieldName as unknown as keyof typeof validations].handler;\r\n// \t\t\t\tif (\r\n// \t\t\t\t\tvalidations[fieldName as unknown as keyof typeof validations].events\r\n// \t\t\t\t\t\t.submit.isActive &&\r\n// \t\t\t\t\ttypeof validationSchema === 'function'\r\n// \t\t\t\t) {\r\n// \t\t\t\t\tvalidatedValues[fieldName] = validationSchema(\r\n// \t\t\t\t\t\tfields[fieldName].value,\r\n// \t\t\t\t\t\t'submit',\r\n// \t\t\t\t\t);\r\n// \t\t\t\t}\r\n\r\n// \t\t\t\terrors[fieldName] = {\r\n// \t\t\t\t\tname: fieldName,\r\n// \t\t\t\t\terror: null,\r\n// \t\t\t\t\tvalidationEvent: 'submit',\r\n// \t\t\t\t};\r\n// \t\t\t} catch (error) {\r\n// \t\t\t\terrors[fieldName] = {\r\n// \t\t\t\t\tname: fieldName,\r\n// \t\t\t\t\terror: currentStore.utils.errorFormatter(error, 'submit'),\r\n// \t\t\t\t\tvalidationEvent: 'submit',\r\n// \t\t\t\t};\r\n\r\n// \t\t\t\t// hasError = true;\r\n// \t\t\t}\r\n// \t\t}\r\n\r\n// \t\tlet manualFieldName: keyof (typeof metadata)['manualValidatedFieldsMap'];\r\n// \t\tfor (manualFieldName of metadata.manualValidatedFields) {\r\n// \t\t\ttry {\r\n// \t\t\t\tconst validationSchema =\r\n// \t\t\t\t\tcurrentStore.validations[manualFieldName].handler;\r\n// \t\t\t\tif (typeof validationSchema === 'function') {\r\n// \t\t\t\t\tvalidatedValues[manualFieldName as string] = validationSchema(\r\n// \t\t\t\t\t\tvalues as FieldsValues,\r\n// \t\t\t\t\t\t'submit',\r\n// \t\t\t\t\t);\r\n// \t\t\t\t}\r\n\r\n// \t\t\t\terrors[manualFieldName as string] = {\r\n// \t\t\t\t\tname: manualFieldName,\r\n// \t\t\t\t\terror: null,\r\n// \t\t\t\t\tvalidationEvent: 'submit',\r\n// \t\t\t\t};\r\n// \t\t\t} catch (error) {\r\n// \t\t\t\terrors[manualFieldName as string] = {\r\n// \t\t\t\t\tname: manualFieldName,\r\n// \t\t\t\t\terror: currentStore.utils.errorFormatter(error, 'submit'),\r\n// \t\t\t\t\tvalidationEvent: 'submit',\r\n// \t\t\t\t};\r\n\r\n// \t\t\t\t// hasError = true;\r\n// \t\t\t}\r\n// \t\t}\r\n\r\n// \t\ttype NecessaryEvil = {\r\n// \t\t\tvalues: FieldsValues;\r\n// \t\t\tvalidatedValues: GetFromFormStoreShape<\r\n// \t\t\t\tReturnType<typeof storeGetter>,\r\n// \t\t\t\t'validatedValues'\r\n// \t\t\t>;\r\n// \t\t\terrors: {\r\n// \t\t\t\t[Key in keyof (typeof metadata)['validatedFieldsNamesMap']]: {\r\n// \t\t\t\t\tname: Key;\r\n// \t\t\t\t\terror: string | null;\r\n// \t\t\t\t\tvalidationEvent: ValidationEvents;\r\n// \t\t\t\t};\r\n// \t\t\t};\r\n// \t\t};\r\n\r\n// \t\tlet errorKey: keyof typeof errors & string;\r\n// \t\tfor (errorKey in errors) {\r\n// \t\t\tconst errorObj = errors[errorKey]; // as NecessaryEvil['errors'][keyof NecessaryEvil['errors']];\r\n\r\n// \t\t\tcurrentStore.utils.setFieldErrors(\r\n// \t\t\t\terrors[\r\n// \t\t\t\t\terrorKey\r\n// \t\t\t\t] as unknown as NecessaryEvil['errors'][keyof NecessaryEvil['errors']],\r\n// \t\t\t);\r\n\r\n// \t\t\tif (typeof errorObj.error !== 'string') continue;\r\n\r\n// \t\t\thasError = true;\r\n// \t\t\t// currentStore.utils.setFieldErrors(\r\n// \t\t\t// \terrors[errorKey], //  as NecessaryEvil['errors'][keyof NecessaryEvil['errors']],\r\n// \t\t\t// );\r\n// \t\t}\r\n\r\n// \t\tcurrentStore.utils.setIsSubmitting(false);\r\n\r\n// \t\tif (hasError) return;\r\n\r\n// \t\tawait cb({\r\n// \t\t\tevent,\r\n// \t\t\tvalues: values as NecessaryEvil['values'],\r\n// \t\t\tvalidatedValues: validatedValues as NecessaryEvil['validatedValues'],\r\n// \t\t\thasError,\r\n// \t\t\terrors: errors as NecessaryEvil['errors'],\r\n// \t\t});\r\n// \t};\r\n// };\r\n\r\n// // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n// type TFunction = (...args: any[]) => any;\r\n// type AnyValueExceptFunctions = // eslint-disable-next-line @typescript-eslint/ban-types\r\n// \tExclude<{} | null | undefined, TFunction>;\r\n// export function handleOnInputChange<\r\n// \tFormStore extends FormStoreShape<any, any>,\r\n// \tName extends keyof GetFromFormStoreShape<FormStore>,\r\n// \tValidationName extends\r\n// \t\t| keyof GetFromFormStoreShape<FormStore, 'validatedValues'>\r\n// \t\t| undefined = undefined,\r\n// >(\r\n// \tstoreGetter: () => FormStore,\r\n// \tname: Name,\r\n// \tvalueOrUpdater:\r\n// \t\t| ((\r\n// \t\t\t\tvalue: GetFromFormStoreShape<FormStore>[Name],\r\n// \t\t  ) => GetFromFormStoreShape<FormStore>[Name])\r\n// \t\t| AnyValueExceptFunctions,\r\n// \tvalidationName?: ValidationName,\r\n// ) {\r\n// }\r\n"],"mappings":"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","names":["isZodValidator","validator","isZodError","error","errorFormatter","formatDate","date","type","formattedDate","year","weekNumber","getWeekNumber","parseDate","dateString","parsedDate","hours","minutes","seconds","yearString","weekString","week","getFirstDateOfWeek","yearStart","daysSinceYearStart","januaryFirst","daysToFirstMonday","firstMonday","daysToTargetMonday","targetMonday","inputDateHelpers","createStore","useId","useState","handleCreateFormStore","params","createStore","createFormStoreBuilder","useCreateFormStore","props","baseId","createFormStoreMetadata","params","baseId","metadata","fieldName","key","createFormStoreValidations","fieldValidationEvents","isFieldHavingPassedValidations","fieldValidationEventKey","validations","fieldValidationsHandler","isZodValidator","value","createFormStoreFields","isUpdatingValueOnError","fields","itemsToResetDefaults","createFormStoreBuilder","set","get","valueOrUpdater","currentStore","itemsToReset","currentState","isDirty","submitCounter","eventKey","name","currentDirtyFieldsCounter","validation","errorFormatter","validationName","field","_validationName","error","cb","event","values","validatedValues","errors","hasError","validationSchema","manualFieldName","errorKey","errorObj"]}